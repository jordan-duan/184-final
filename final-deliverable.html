<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 30px 40px;
			}


			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Final Project Proposal</h1>
		<figure>
			<img src="proposal_images/title.png" alt="title" style="width:70%"/>
		</figure>
		<div style="text-align: center;">Names: Isabella Alpert, Joel Castro, Jordan Duan & Robert Nochez</div>
		<div style="text-align: center;">Proposal Webpage: <a href="https://jordan-duan.github.io/184-final/proposal.html">https://jordan-duan.github.io/184-final/final-deliverable.html</a></div>
		<div style="text-align: center;">Slides: <a href="https://docs.google.com/presentation/d/1LGZGMx-Mz_L71ofXkpk-BMonL71gfiy98YgM6XWvmuM/edit?usp=sharing">https://docs.google.com/presentation/</a></div>
		<div style="text-align: center;">Video: <a href="https://jordan-duan.github.io/184-final/proposal.html">https://jordan-duan.github.io/184-final/proposal.html</a></div>


		<h2>Abstract</h2>

		<p>
			In our final project, Spheres & Physics, but in Minecraft!, we modded Minecraft to introduce two major enhancements: 
			spheres that interacted with physics and custom shaders. The spheres feature realistic physics, particle effects, and 
			sound effects. Moreover, we utilized unique textures and toggled custom properties to create a variety of spheres that 
			exhibited distinct behaviors and properties. Additionally, we implemented custom shaders to alter the game's rendering
			style. When combined, our spheres and shaders add an interesting and dynamic layer on top of Minecraft.
		</p>

		<h2>Technical Approach</h2>

		<h3>Spheres</h3>

		<h3>Shaders</h3>

		<p>
			Implementing custom shaders in Minecraft was challenging due to limited native support and sparse documentation. Most 
			online resources assume the use of OptiFine or Iris, but we opted to work within the base Fabric environment to ensure 
			compatibility with our voxel-based simulation. This meant re-implementing effects like Blinn-Phong, normal 
			visualization, blur, and sharpening from scratch. Unlike reference OpenGL projects with full shader flexibility, 
			Minecraft's engine restricted dynamic uniform control and runtime toggling, so we simplified our pipeline and leaned 
			on the in-game settings menu to switch shaders rather than introducing GUI controls or extra mod dependencies. 
		</p>

		<p>
			<b>Enhanced:</b> Our most dynamic shader that adds sky rendering with fog, stars, and clouds, shadow mapping with 
			distortion, water rendering, physically-based rendering, reflection and ray marching, and deferred shading. We tried 
			to implement a bidirectional reflectance distribution function that combines the specular and diffuse reflections 
			using this formula of the Cook-Torrance model: <code>vec3 BRDF = (phongDiffuse + cookTorrance) * NdotL;</code> to get 
			the diffuse reflection on Lambert's cosine law, and then we also determine shadow intensity by comparing the sun 
			fragment depth and shadow map depth with simple math.
		</p>

		<p>
			<b>Pixelization:</b> This shader applies a pixelization effect by downsampling the screen-space UV coordinates on the 
			block into fixed grid size to reduce the resolution of the scene by sampling the texels in the grid pattern.The shader 
			samples a single texel per grid cell and replicates its color across the cell, creating a retro, low-resolution 
			aesthetic. This effect is achieved by manipulating the UV coordinates before sampling the texture. In the code, we 
			grid sample by adjusting the texture coordinates to sample a single texel per grid cell, effectively 
			<code>vec2 pixelCoord = floor(texCoord / pixelSize) * pixelSize;</code>, basically downsampling texture.
		</p>

		<p>
			<b>Blur:</b> The blur shader applies a Gaussian blur effect to the screen by sampling neighboring pixels using a 
			weighted kernel. It calculates the average color of nearby pixels based on their weights and outputs the blurred 
			result. This shader is useful for creating soft-focus effects or smoothing textures. It also makes it look like you 
			have cataracts. The math behind this is that the kernel is a 7x7 matrix that approximates Gaussian distribution with 
			the weights, and the weights are skewed toward the center. Then with this code, 
			<code>result += texture(gcolor, texCoord + offset).rgb * weight;</code>, it loops over each fragment and computes the 
			weighted sum of neighboring texels. We then get a normalized value by dividing by sum of weightSum and the output will 
			be within [0,1].
		</p>

		<p>
			<b>Fog:</b> The fog shader adds atmospheric fog to the scene based on the distance from the camera. It blends the 
			scene's colors with a fog color, with the intensity determined by distance and height.  It uses exponential 
			attenuation and height-based density modulation for realistic fog effects. The math behind the intensity is that it 
			exponentially increases with distance, which is what fog does, <code>float fogAmount = 1.0 - exp(-distance * fogDensity);</code> 
			and modules the fog intensity based on fragment height in <code>fogAmount *= smoothstep(20.0, -10.0, worldPos.y);</code>
			to emulate a field of vision when you're in fog. We also tried to do light scattering in this portion through the fog 
			but weren't able to implement it in the end, it would always cause aliasing or artifacting.
		</p>

		<p>
			<b>Grayscale:</b> The grayscale shader converts the scene’s colors to grayscale by calculating the luminance of each 
			pixel. It uses a weighted average of the red, green, and blue channels to determine the brightness. This shader is 
			ideal for creating a monochromatic or desaturated visual style. It is also good for debugging. In this code, 
			<code>float grayscale = dot(color.rgb, vec3(0.299, 0.587, 0.114));</code>, we calculate the luminance through the 
			weighted sum of RGB values.
		</p>

		<p>
			<b>Normal:</b> This shader encodes surface normals into a normalized color space [0, 1] [0, 1], allowing easy 
			visualization and debugging of geometry. Green areas represent normals along the positive Y-axis, red along X, and 
			blue along Z; blended colors indicate intermediate directions. Technically, it transforms normals from view space to 
			world space using the inverse model-view matrix and outputs them as RGB values in a texture. This is useful in deferred 
			rendering pipelines or for verifying normal maps in lighting calculations. In the math behind it, we convert normals from 
			view space to world space, <code>normal = mat3(gbufferModelViewInverse) * normal;</code> and maps the normal vector from [-1,1] to 
			[0,1] to store in a texture in <code>encodedNormal = vec4(normal * 0.5 + 0.5, 1.0);</code>.
		</p>

		<p>
			<b>Sprite-Colored:</b> This shader shows how lighting values are stored within the lightmap, with red areas indicating 
			only blocklight, green areas indicating only sunlight, and yellow areas indicating a combination of blocklight and 
			sunlight. It outputs encoded normals and lightmap data to the G-buffer for integration into the deferred rendering 
			pipeline. The math behind it is that it combines texture, vertex, and lightmap color contributions in 
			<code>color = texture(gtexture, texcoord) * glcolor * texture(lightmap, lmcoord);</code> for color blending, and then 
			we discard any fragments under a certain threshold of transparency.
		</p>

		<h3>Problems We Encountered</h3>

		<h3>Lessons We Learned</h3>

		<p>
			We learned that Minecraft's rendering model significantly differs from traditional OpenGL, requiring creative 
			adaptation of standard shading techniques. Entity rendering proved essential for realistic lighting, as blocks are 
			too limited for fragment-level effects. We also realized that minimizing feature creep—like dynamic shader 
			switching—helped maintain project stability. Most importantly, debugging shaders in this environment was difficult 
			without tools like RenderDoc, so we relied on careful visual feedback (e.g., using RGB encodings of normals) and 
			iterative testing to verify our implementations.
		</p>
		
		<h2>Results</h2>

		<h2>References</h2>

		<ul>
			<li><div>Iris Docs (Shaders Documentation): <a href="https://shaders.properties/">https://shaders.properties/</a></div></li>
			<li><div>Fabric Modding Developer Documentation: <a href="https://docs.fabricmc.net/develop/">https://docs.fabricmc.net/develop/</a></div></li>
			<li><div>Template Used to Create Sphere Mod Structure: <a href="https://fabricmc.net/develop/template/">https://fabricmc.net/develop/template/</a></div></li>
			<li><div>Minecraft Entity Methods: <a href="https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/server/entity?view=minecraft-bedrock-stable">https://learn.microsoft.com/en-us/minecraft/creator/scriptapi/minecraft/</a></div></li>
			<li><div>OpenGL Lighting and Shading Techniques: <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">https://learnopengl.com/Advanced-Lighting/Advanced-Lighting</a></div></li>			
			<li><div>Shader Tutorial Video: <a href="https://www.youtube.com/watch?v=RjyNVmsTBmA&ab_channel=SamuelGerkin">https://www.youtube.com/watch?v=RjyNVmsTBmA&ab_channel=SamuelGerkin</a></div></li>			
		</ul>

		<h2>Contributions From Each Team Member</h2>
		
		</div>
	</body>
</html>